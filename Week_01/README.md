#学习笔记第一期


###一、字节码
+ 生成字节码
    + javap ‐c -verbose .class文件
    + -verbose 输出附加信息 如常量池、访问标志符、方法详情（栈深度、本地变量数、参数数量）等
+ 字节码解读
    + 数据类型 int(i)、long(l)、float(f)、double(d)、short(s)、byte(b)、char(c)、对象引用(a)
    + 注：byte、short、char 都将转换为int类型
    + 字节码命令 
        + 操作栈指令
            pub、pub2、pub2_2
        + 加载与存储
            + store: 弹出操作栈中的元素放入指定局部变量数组索引位置
            + load: 将指定局部变量压入操作栈中
            + const系列: bipush、sipush
            + ldc: 以上指令都不满足需求是使用该指令
            + 数据类型+操作类型+位置=指令 如 istore_1 iload_1 aload 5
        + 算数指令
            + 类型+操作 如：iadd idiv imul
            + inc 自增1
        + 类型转换
            + i2b 类型A2类型B
        + 方法调用
            invokevirtual、invokeinterface、invokespecial、invokestatic、invokedynamicn
        + 比较指令
            + dcmpg, dcmpl、 fcmpg、 fcmpl、 lcmp
        + 异常处理指令
        + 同步指令
###二、类加载*
+ 类的生命周期
    + 加载->(校验->准备->解析)(统称链接)->初始化->使用->加载
    + 加载，验证，准备，解析，初始化 统称为类加载
+ 阶段简介
    + 加载: 加载文件系统中的jar中或其它地方的class文件（jvm + 类加载器共同完成）
    + 校验: 判断字节码的合法性
    + 准备:
        + 创建静态字段，并将其初始化为标准默认值(null和0)
        + 分配方发表(在方法区中分配变量的内存空间)
    + 解析: 解析常量池，主要有 类或接口、字段、类方法、接口方法
        + 将.class文件中以符号引用来存储的解析并连接为直接引用(直接引用的目标必定存在堆中)
    + 初始化: 首次主动使用的时候才能执行类初始化(如调用类方法、new 一个类)
        + 类构造器方法
        + static静态变量赋值语句(注:准备阶段是默认值，这里是赋值)
        + static静态编码块
    + 使用:
    + 销毁
+ 类加载时机
    + 虚拟机启动时，初始化用户指定的主类 如main
    + 主动new一个类
    + 调用静态方法和字段时，初始化静态方法类
    + 初始化子类，父类也会初始化一直到最顶级父类
    + 接口default方法，会初始化接口的初始化和直接或间接实现该接口的类
    + 使用反射API对某个类反射调用的时候
    + 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的 类。
+ 不会类初始化情景
    + 调用父类静态字段，只会初始化父   类
    + 定义List对象数组时 对象不会初始化
    + 通过类名、Hello.class 不会初始化
    + Class.forName initialize(true/false) 判断是否初始化
    + ClassLoader loadClass 不会触发初始化
+ 类加载器分类
    + 启动器: 加载Java的核心类，由原生代码实现，开发者无法变更引用
    + 扩展类: 加载jre扩展目录   lib/ex 或  java.ext.dirs
    + 应用类: 项目中写的类
+ 加载器特点
    + 双亲委托: 一直寻找父级，一直找到最顶级父级
    + 负责依赖: 类中的依赖全部加载
    + 缓存加载: 初始化一次就缓存下来不在初始化
###三、JVM内存*
+ 线程栈
    + Java 虚拟机栈
        + 栈帧
            + 每个方法会创建一个栈帧(Frame帧)
            + 操作数栈+局部变量表
        + 是固定大小的，不会扩容，每个线程的容量大了线程总量就会少
        + Xss命令设置大小(栈深度) 
        + StackOverflowError 异常
+ 堆
    + 老年代
    + 新生代
        + 划分
          + eden 
          + survivor(s0 + s1)
            + 避免并发下对象指针分别维护线程安全的问题
                + TLAB 本地线程分区缓冲
                + CAS 匹配失败机制
          + 比例 8:1:1
          + s0和s1总有一个是空的因：两个区域相互是对方区域整理后复制过去，然后清除本区域。
        + 流程
          + 新对象先写入 eden区
          + 当eden到gc 限度，将eden区、s0或s1，还存活的信息复制到 s0或s1中（哪个是空的复制到哪个）
          + 清空eden、s0或s1(清空被复制的哪个区)
          + 同理 s0或s1也是这个样， 当在s0或s1度过15次gc(系统默认，可以自己设置)后将写入老年代
            + MaxTenuringThreshold = 15 设置 
        + OutOfMemoryError   
+ 非堆(又叫方法区)
   + jdk8 主要由MetaSpace组成(元数据区)
        + 主要存放加载类的信息、静态变量、final类型的常量、属性和方法信息
   + CompressedClassSpace
        + 存放class信息和Metaspace有交叉
   + CodeCache
        + 存放JIT编译器后的本地机器代码
+ JVM自身
   + 自身运行所需要的的内存
+ 直接内存
    + NIO
    + JNI（外部扩展 c写的扩展）
    
###四、GC 垃圾回收*
+ GC中并发和并行的区别
    + 并发: 业务和GC可以同时进行
        + 原理
            + 在与业务同时进行时，会出现两个情况
                + 已经扫描过的，且下面的引用全部扫描过， 又出现新的引用
                + 已经扫描过的，切下面的引用至少有一个没有被扫描， 那个引用关系有给删除(断掉了)
            + 针对第一种情况 增量更新(CMS)-> 新增引用关系是记录下来， 并发扫描结束之后，然后在将新增的节点的对象为根重新扫描一遍
            + 很对第二种情况 原始快照(G1 Shenandoah)-> 扫描快照后，将删除关系的节点记录下来，并发扫描结束后，将在删除节点的对象为根对象重新扫描一遍
    + 并行: 多个线程在处理GC，其它业务有可能会SWT
+ Xms和Xmx 设置一样大的好处
    + 当Xms太小的时候， 到了临界点会频发进行gc 如果内存不够了才会进行扩容
    + 扩容时 会进行 full gc 会 SWT影响大
    + 避免每次垃圾回收完成后JVM重新分配内存
+ 名词解释
    + Partial GC 部分收集
        + MinorGC / Young GC 新生代垃圾收集
        + MajorGC / Old GC 老年代垃圾收集
    + Mixed GC 混合收集 整个新生代以及部分老年代垃圾收集（G1 GC中使用到）
    + Full GC 整个Java堆和方法区的垃圾收集
    + Oop Map  是一个附加的信息，告诉你栈上哪个位置本来是个什么东西
        + 只有在 安全点上 记录信息
        + 安全区:指能够确保在一段时间内，引用关系不会发生变化，可以在区域中任意地方开始垃圾回收
    + 卡表 待补充 里属于remember set
    + 可达对象
        + 基于一个能保证一致性的快照
+ 算法
    + GC暂停 SWT（停止一切） 解决清理对象的时候，有可能会出现一个对象一开始不可用，在清理过程中又被引用了这种问题
    + 标记清除算法(Mark and Sweep)
        + 从根对象(GC roots)出发，遍历可达对象(引用的对象一直到最后)，并标记
            + 哪些可以作为根对象
                + 正在执行的方法里的局部变量和输入参数(GWT时 正在执行的方法变量和参数)
                + 活动线程
                + 所有类的静态字段
                + JNI引用
                + 新生代和老年代 引用关系(当新生代晋升为老年代时会存在 跨代引用)
                    + 专门有个集合记录跨代引用关系（RememberSet Rset）
        + 将未被标记的对象(不可达对象)清除掉
        + 缺点
            + 会出现不连续内存碎片，内存不连续（导致如果有大对象需要连续内存存储的时候找不到，但空间却很大）
            + 执行效率不稳定 （执行效率会随着标记对象的数量而降低）
        + 优点
            + 解决互相引用(循环依赖)问题、不用标记所有对象，只扫描部分对象
        + 特点: 清除快，分配慢 分配慢 造成吞吐量下降
    + 复制算法(Mark-Copy)  
        + 将可用内存按容量划分为大小相等的两块，每次只是有其中一块，当一块的内存用完了，就将还存活的对象复制到另外一块上面，然后把已使用过的内存空间清除
        + 年轻代运用复制算法
        + 优点
            + 每次针对整个半区进行内存回收
            + 分配内存不用考虑有空间碎片的复杂情况，只要一动堆针，按顺序分配即可
        + 缺点
            + 可用空间为原来的一半，空间浪费较多
        + 注意: 
            + 目前用的是Appel式回收 即 Eden survivor 8:1:1 解决了复制算法的缺点
            + 如果进行一次 Young GC 时 survivor 内存不够一次的，将进行分配担保
             + 对象存活率较高时进行较多复制操作，效率会降低。
                + 老年代一般不能直接选用这种算法， 如果不想浪费50%的空间，就需要有额外的空间进行分配担保(应对100%对象都存活的极端情况)
    + 整理算法(Mark-Sweep-Compact)
        + 一开始和标记清除算法一样，清除数据。 然后将剩余对象 向内存空间一端移动，然后清理掉边界以外的内存
        + 去除内存碎片，空出连续内存
        + 特点: 清除慢，分配内存快
+ 分代假设
    + 年轻代和老年代的GC算法是不一样的，因年轻代都是新创建的存货周期短，老年代存活周期长，所以区分算法
    + 年轻代->老年代 叫做晋升
    + 年轻代: 复制算法 为什么？
        + 因年轻代98%的对象都将被清理， 将少有的复制到一个存活区，这样分配内存不用考虑有空间碎片的复杂情况，只要一动堆针，按顺序分配即可
    + 老年代: 移动算法 为什么？
        + 因为 老年代 大部分是不会被清理掉的 ，复制算法需要预留出一部分内存空间以防止 100% 类不需要回收的情况， 所以不适用复制算法
        + 采用 移动+整理， 一开始使用标记-清除，当无法容忍后，采用标记-整理
+ JDK各个版本默认GC策略
    + 8之前都是并行GC   8之后都是G1
+ 串行GC(Serial GC / ParNew GC) ***
     + 触发条件
        + 某个区域满了
        + 大对象没有地方放了
    + 特点
        + 单线程，不能并行处理。都会触发SWT
        + CPU利用率高，暂定时间长。
    + 配置: -XX: +UseSerialGC 
    + 算法
        + 年轻代: mark-copy
        + 老年代: mark-sweep-compact
    + 适用内存大小：几百MB
    + 改进版：ParNewGC
        + 配合CMS使用
        + 配置: +UseParNewGC
        + 特点: 改为多线程处理
+ 并行GC(Parallel GC)
    + 触发条件
        + 某个区域满了
        + 大对象没有地方放了
    + 特点:
        + 多线程
        + 不做GC时，没有GC线程运行的， 只有需要GC时才会启动线程，不会额外消耗资源
        + 总暂停时间更短
    + 算法:
        + 新生代: mark-copy
        + 老年代: mark-sweep-compact
    + 配置
        + 默认配置
            + 堆: 如果不设置最大堆内存，则默认为物理内存的1/4
            + 年轻代: 默认物理内存的1/16
            + 年轻代最大: 默认1/3  ?????
        + -XX: +UseParallelGC 新生代使用
        + -XX: +UseParallelOldGc 老年代使用
        + -XX: ParallelGCThreads=N 来设定GC线程数，默认为CPU核数
    + 适用场景
        + 多核CPU
        + 对服务吞吐量要求较高
    + 优点:
        增加吞吐量(更有效的使用系统资源)
    + 问题:
        为什么 执行GC的线程数和CPU数量相同是最好的？
        
+ CMS GC(Mostly Concureent Mark and Sweep Garbage Collector)
    + 触发条件
        + 设置触发值，到达预值进行触发
        + 大对象没有地方放了
    + 算法
        + 年轻代 并行SWT 方式的 mark-copy 算法
        + 老年代 并发 mark-sweep 算法
    + 配置
        + +UseConcMarkSweepGC
    + 默认配置
        + 堆: 如果不设置最大堆内存，则默认为物理内存的1/4
        + 年轻代: 默认物理内存的1/16
        + 年轻代最大: 64(64位机器) * 4(并行GC线程数) / 13 * 10 (13 * 10 是一个系数)
    + 特点:
        + 避免在老年代收集时出现长时间卡顿
            + 不对老年代进行整理(压缩) 使用空闲列表（free-lists）管理内存空间的回收
            + 在mark-and-sweep阶段 大部分工作和业务应用一起并发执行
        + 没有明显的应用线程暂停
        + 在惊醒老年代并发回收时，可能伴随多吃年轻代的 minorGC
    + 适用场景:
        +主要钓友目标是降低GC 停顿导致的系统延迟
    + 注意: 因为是并发执行的， 所以会和应用线程强CPU，所以不要设置过多的线程数 一般为CPU核数的1/4
    + 优点:
        + SWT时间短
    + 缺点:
        + 复杂度高
        + 清理总时间变长
        + 老年代内存碎片不会被清理 有可能会初见不可预测的暂停时间，特别是堆内存较大的情况下
    + 六个阶段
        + Initial Mark (初始标记) SWT 
            + 标记根对象和根对象引用的第一个对象
            + 跨代的标记（引用的第一个对象）
        + Concurrent Mark (并发标记)
            + 标记根对象引用的第一个对象之后的对象 粗略的标记(因为对象间的关系一直在变)
        + Concurrent Preclean (并发清理)
            + 在第二阶段中类关系发生变化的 给上不同标记
        + Final Remark(最终标记) SWT
            + 确认最终 类之间的引用关系
        + Concurrent Sweep(并发清除)
            + 删除不再使用的对象
        + Concurrent Reset(并发重置)
            + 重置之前步骤中相关的内部数据
            
+ G1 GC(Garage-First) 垃圾优先
    + 触发条件
        + 设置触发值，到达预值进行触发 默认为 堆内存的45%
        + 大对象没有地方放了
    + 配置
        + -XX:UseG1GC
        + -XX:MaxGCPauseMillis = 50(单位毫秒) 设置GC执行时间 默认200
        + -XX:G1NewSizePercent 初始化整个年轻代的大小 默认值为 5%
        + -XX:G1MaxNewSizePercent 最大年期待整个堆的小小 默认为60%
        + -XX:G1HeapRegionSize 设置每个内存块(Region)的大小,单位为MB， 需要为1，2，4，8，16，32 2N次方 的某个值，默认为堆内存的1/2000. 如果设置内存块设置较大 大对象也可以存入一个内存块中
        + -XX:ConcGcThreads 并发GC线程数，默认 1/4  要研究一下配置，因为 过低导致GC能力不足，过高又与业务抢占资源
        + -XX:InitiatingHeapOccupancyPercent(简称 IHOP) G1内部并行回收循环启动阈值，何时回收 默认为堆的45%
            + 当老年代 大于等于45%的时候，JVM启动垃圾回收， 决定了什么时间启动老年代并行回收
        + -XX:G1HeapWastePercent: 停止回收的最小内的大小，默认为5%
            + 不需要每次都全部回收完毕，可以遗留少量下次处理，好处:降低了单次消耗的时间
        + -XX:+GCTimeRatio 应用线程和GC线程处理时间比率， 默认是9
            + 公式 100/(1+GCTimeRatio)
            + 因为不需要扫描整个内存堆
        + -XX: MaxGCPauseMills 每次执行的暂停时间，单位是毫秒 默认200毫秒
    + 内存划分  
        + 改为矩阵 分割成很多个小内存块（2048个）， 每个小内存块被标记为不同的内存如 Eden区 存活区 老年代
        + 好处是 按需调配资源
    + 特点
        + 内存划分更改
        + 按需调配资源
        + 不用每次都去收集整个堆空间，以增量的方式进行处理（优先处理垃圾比较多的内存块）
        + 一开始有可能会慢 有了统计数据之后，进行调整
        + 会根据之前的统计数据 会调整触发GC的条件， 启发式GC
    + 处理步骤
        + 年轻代模式转移暂停(Evacuation Pause)
            + 刚启动时G1没有足够信息，使用fully-young模式
            + 当年轻代空间满了以后，应用线程会被暂停，将年轻代内存块中的存活对象拷贝到存活区，如果还没有存活区，则任意选择一部分空闲内存块作为存活区
            + 拷贝的过程成为转移 mark-copy
        + 并发标记(Concurrent Marking)
            + 通过 Snapshot-At-The-Beginning(起始快照)。记入现阶段存活对象
            + 需要一块类似TLAB 的缓存区
            + 当内存总体使用比例达到一定数据
            + 阶段
                + Initial Mark 初始标记 SWT
                    + 标记所有从GC根对象直接可达的对象
                + Root Region Scan (Root区扫描)
                    + 标记从 根区域 可达、的对象 根区域包括：非空的区域，在标记过程中不得不收集的区域
                + ConcurrentMark (并发标记)
                + Remark(再次标记) SWT
                    + 停止并发封信信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象
                + Cleanup(清理) SWT
                    + 统计小堆块中的所有存活的对象，并将小堆块排序，以提升GC的效率，维护并发标记的内容状态
        + 转移暂停：混合模式(Evacuation Pause(mixed))
                + 不止清理年轻代，还处理一部分老年代
                + 不一定紧跟并发标记阶段， 很多规则和历史数据会影响启动时机 比如： 老年代可以在并发地藤虎很多的小堆块
                + 并发标记与混合转移暂停之间，可能会存在很多次 young模式的暂停转移
    + 注意
        + 在触发Full GC的时候 有可能会退化为 Serial 单线程来完成垃圾的清理工作 有可能会达到秒级别
        + 并发模式失败
            + 条件:在混合标记之前，发下老年代被填满
            + 解决方法: 增加堆大小,或调整周期(如 增加线程数)
        + 晋升失败
            + 条件: 没有足够的内存供活动对象或晋升对象使用，由此出发了Full GC
            + 解决方法:
                + 增加堆的大小
                + 增加预留内存量 -XX: G1ReservePercent
                + 增加GC线程数 增加处理GC的能力
        + 巨型对象分配失败
            + 条件: 巨型对象找不到黑的空间进行分配，由此启动Full GC 来释放空间
            + 解决方法:
                + 增加堆内存
                + 增加内存块的大小(Region) -XX: G1HeapRegionSize
+ 常见GC组合
    + Serial + Serial Old  单线程低延迟
    + ParNew + CMS 多线程低延迟
    + Parallel Scavenge 和 Parallel Scavenge 多线程 高吞吐量  
       
+ 如何选择正选的GC
    + Parallel GC 系统吞吐量优先
    + CMS 低延迟优先 GC时间尽量短
    + G1  内存推较大，平均GC时间可控
+ 对内存大小的考量
    + 4G 以上算较大 G1性价比高
    + 超过 8G 如 16-32G， 非常推荐使用G1 GC 
    
+ ZGC
    + 配置
        + -XX:+UnlockExperimentaIVMOptions -XX: +UseZGC -Xmx16g
    + 特点
        + 最大停顿时间不超过10ms
        + 堆内存支持范围广，小至几百MB，大至 4TB的超大堆内存(JDK13 提升至16TB)
        + 与G1相比，应用兔兔量下降不超过15%
        + 当前只支持 linux/64 为 JDK15 后支持MacOS和 Windows
        + 移动对象的时候，源对象的引用变为新对象的地址，等都移动完成后丢弃